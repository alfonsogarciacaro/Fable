
# Numbers in Fable



Fable numbers are very nearly compatible with .NET semantics, but translating into Javascipt types has consequences:

* (non-standard) All floating point numbers are implemented as 64 bit (double). This makes `float` numbers more accurate than expected.
* (non-standard) Arithmetic integers of 32 bits or less are implemented with different truncation from that expected, as (whole number) doubles.
* (OK) Conversions between types are correctly truncated.
* (OK) Bitwise operations are all correct, and when made on 32 bit integers are truncated to 32 bits.
* (OK) Longs have a custom implementation which is identical in semantics to .NET and truncates in 64 bits: although it is quite slow.

32 bit integers thus differ from .NET in two ways:

* Underlying 52 bit precision, without expected truncation to 32 bits on overflow. Truncation can be forced if needed by `>>> 0`.
* On exceeding 52 bits absolute value floating point loses precision. So overflow will result in unexpceted 0s in lower order bits.

The loss of precision can be seen in a single multiplication:

```
(1 <<< 28 + 1) * (1 <<< 28 + 1) >>> 0
```

The multiply product will have internal double representation rounded to `0x0100,0000,2000,0000`. When it is truncated to 32 bits by
`>>> 0` the result will be  `0x2000,0000` not the .NET exact lower order bits value of `0x2000,0001`.

The same problem can be seen where repeated arithmetic operations make the internal (non-truncated) value large. For example a linear
congruence random number generator:

```
let rng (s:int32) = 10001*s + 12345
```

The numbers generated by repeated application of this to its result will all be even after the 4th pseudo-random number when `s` value exceeds 2^53.

## Workarounds

* When accurate low-order bit arithmetic is needed and overflow can result in untruncated numbers larger than 2^53 use `int64`, `uint64`, which is exact 64 bits, instead of `int32`, `uint32`.
* Alternately, truncate all arithmetic with `>>> 0` or `>>> 0u` as appropriate before numbers can get larger than 2^53.


## Printing

One small change from .NET in `printf`, `sprintf`, `ToString`. Negative signed integers are printed in hexadecimal format as sign + magnitude,
in .Net they are printed as two's complement bit pattern.