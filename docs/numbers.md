
# Number in Fable



Fable numbers are very nearly compatible with .NET semantics, but translating into Javascipt types has two consequences:

* All floating point numbers are implemented as 64 bit (double). This makes `float` numbers more accurate than expected.
* Arithmetic integers of 32 bits or less are implemented with different truncation from that expected, as (whole number) doubles.
* Conversions between types are correctly truncated.
* Bitwise operations are all correct, and when made on 32 bit integers are truncated to 32 bits.
* Longs have a custom implementation which is identical in semantics to .NET and truncates in 64 bits: although it is quite slow.

Int32 or lower differs from .NET in two ways:

* Underlying 52 bit precision, without expected truncation to 32 bits on overflow. Truncation can be forced if needed by `>>> 0`.
* On exceeding 52 bits absolute value floating point loses precusion. So overflow will result in unexpceted 0s in lower order bits.

The loss of precision can be see in a single multiplication:

```
(1 <<< 28 + 1) * (1 <<< 28 + 1) >>> 0
```

The multiply product will have internal double representation rounded to `0x0100,0000,2000,0000`. When it is truncated to 32 bits by
`>>> 0` the result will be  `0x2000,0000` not the .NET exact in lower order bits `0x2000,0001`.

The same problem can be seen where repeated arithmetic operations make the internal (non-truncated) value large. For example a linear
congruence random number generator:

```
let rng (s:int32) = 10001*s + 12345
```

The numbers generated by this will all be even after the 4th random number when the seen value exceeds 2^53.


## Printing

One small change from .NET in `printf`, `sprintf`, `ToString`. Negative signed integers are printed in hexadecimal format at sign + magnitude,
in .Net they are printed as two's complement bit pattern.