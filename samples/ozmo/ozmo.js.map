{"version":3,"sources":["../samples/browser/ozmo/ozmo.fsx"],"names":[],"mappings":"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","file":"ozmo.js","sourcesContent":["(**\r\n - title: Ozmo game\r\n - tagline: Phil Trelford's classic ported to Fable\r\n - app-style: height:668px; width:900px; margin:20px auto 20px auto;\r\n - intro: Phil Trelford's [classic Ozmo game](https://twitter.com/ptrelford/status/475395178208174080), originally hosted\r\n   [on BitBucket](https://bitbucket.org/ptrelford/ozmo) ported to Fable! Shows how to handle keyboard events and\r\n   use HTML5 canvas. You can also get it (as a JavaScript app) from [the Windows\r\n   Store](https://www.microsoft.com/en-gb/store/apps/ozmo/9nblggh4rjng). View the [raw source code on\r\n   GitHub](https://github.com/fsprojects/Fable/blob/master/samples/browser/ozmo/ozmo.fsx).\r\n   To play the game, use left and right keys!\r\n\r\n\r\n*)\r\n(*** hide ***)\r\n#r \"node_modules/fable-core/Fable.Core.dll\"\r\nopen Fable.Core\r\nopen Fable.Import.Browser\r\n\r\nlet min a b = if a > b then b else a\r\nlet max a b = if a > b then a else b\r\n\r\n[<Emit(\"Math.random()\")>]\r\nlet rand (): float = failwith \"JS only\"\r\n\r\nmodule Keyboard =\r\n  let mutable keysPressed = Set.empty\r\n  let code x = if keysPressed.Contains(x) then 1 else 0\r\n  let arrows () = (code 39 - code 37, code 38 - code 40)\r\n  let update (e : KeyboardEvent, pressed) =\r\n    let keyCode = int e.keyCode\r\n    let op =  if pressed then Set.add else Set.remove\r\n    keysPressed <- op keyCode keysPressed\r\n    null\r\n  let init () =\r\n    window.addEventListener_keydown(fun e -> update(e, true))\r\n    window.addEventListener_keyup(fun e -> update(e, false))\r\n\r\n/// The width of the canvas\r\nlet width = 900.\r\n/// The height of the canvas\r\nlet height = 668.\r\n/// Height of the floor - the bottom black part\r\nlet floorHeight = 100.\r\n/// Height of the atmosphere - the yellow gradient\r\nlet atmosHeight = 300.\r\n\r\nKeyboard.init()\r\n\r\nlet canvas = document.getElementsByTagName_canvas().[0.]\r\nlet ctx = canvas.getContext_2d()\r\ncanvas.width <- width\r\ncanvas.height <- height\r\n\r\n(**\r\nThis demo shows a simple game written using Fable and HTML5 canvas. One interesting\r\naspect of the game is the [asynchronous game loop](#Asynchronous-game-loop), which \r\nupdates the game state 60 times per second in a loop. This is implemented using F#\r\nasynchronous workflows, which make it possible to capture the logic as a recursive \r\nfunction, rather than using mutable state.\r\n\r\nThe Ozmo game uses the [Keyboard helpers from the Mario sample](../mario/index.html#Keyboard-helpers),\r\nso if you want to see those, check out the Mario sample first - it is also simpler, \r\nso you can check it out for lighter introduction to Fable and F#.\r\n\r\n## Drawing the world\r\n\r\nThe first few functions in the game deal with rendering. The world consists of two\r\ngradients (with yellow orange gradient in the sky and gray gradient for the atmosphere)\r\nand a filled black rectangle. The `drawGrd` function draws a gradient and `drawBg`\r\nrenders the world. We also need `drawText` for printing text when the game finishes:\r\n\r\n*)\r\n/// Draw gradient between two Y offsets and two colours\r\nlet drawGrd (ctx:CanvasRenderingContext2D)\r\n    (canvas:HTMLCanvasElement) (y0,y1) (c0,c1) =\r\n  let grd = ctx.createLinearGradient(0.,y0,0.,y1)\r\n  grd.addColorStop(0.,c0)\r\n  grd.addColorStop(1.,c1)\r\n  ctx.fillStyle <- U3.Case2 grd\r\n  ctx.fillRect(0.,y0, canvas.width, y1- y0)\r\n\r\n/// Draw background of the Ozmo game\r\nlet drawBg ctx canvas =\r\n  drawGrd ctx canvas\r\n    (0.,atmosHeight) (\"yellow\",\"orange\")\r\n  drawGrd ctx canvas\r\n    (atmosHeight, canvas.height-floorHeight)\r\n    (\"grey\",\"white\")\r\n  ctx.fillStyle <- U3.Case1 \"black\"\r\n  ctx.fillRect\r\n    ( 0.,canvas.height-floorHeight,\r\n      canvas.width,floorHeight )\r\n\r\n/// Draw the specified text (when game finishes)\r\nlet drawText(text,x,y) =\r\n  ctx.fillStyle <- U3.Case1 \"white\"\r\n  ctx.font <- \"bold 40pt\";\r\n  ctx.fillText(text, x, y)\r\n(**\r\n## Representing and drawing blobs\r\n\r\nEach of the balls in the game is represented by a `Blob` value that stores\r\nthe X and Y coordinates, size of the blob (radius), its colour and current speed.\r\nThe type is used for both falling blobs and for the player's blob:\r\n*)\r\ntype Blob = \r\n  { X:float; Y:float; \r\n    vx:float; vy:float; \r\n    Radius:float; color:string }\r\n(**\r\nDrawing blob on the canvas is quite easy - the following function does that using\r\nthe `arc` function of the 2D rendering context of the canvas:\r\n*)\r\nlet drawBlob (ctx:CanvasRenderingContext2D) \r\n    (canvas:HTMLCanvasElement) (blob:Blob) =\r\n  ctx.beginPath()\r\n  ctx.arc\r\n    ( blob.X, canvas.height - (blob.Y + floorHeight + blob.Radius), \r\n      blob.Radius, 0., 2. * System.Math.PI, false )\r\n  ctx.fillStyle <- U3.Case1 blob.color\r\n  ctx.fill()\r\n  ctx.lineWidth <- 3.\r\n  ctx.strokeStyle <- U3.Case1 blob.color\r\n  ctx.stroke()\r\n(**\r\n\r\n## Falling blobs and collisions\r\n\r\nThe next step is to define the physics for the game. This consists of several\r\nfunctions that update the `Blob` objects and are composed to apply all rules of\r\nphysics in the main game loop.\r\n*)\r\n/// Apply key effects on Player's blob - changes X speed\r\nlet direct (dx,dy) (blob:Blob) =\r\n  { blob with vx = blob.vx + (float dx)/4.0 }\r\n\r\n/// Apply gravity on falling blobs - gets faster every step\r\nlet gravity (blob:Blob) =\r\n  if blob.Y > 0. then { blob with vy = blob.vy - 0.1 }\r\n  else blob\r\n\r\n/// Bounde Player's blob off the wall if it hits it\r\nlet bounce (blob:Blob) =\r\n  let n = width\r\n  if blob.X < 0. then \r\n    { blob with X = -blob.X; vx = -blob.vx }\r\n  elif (blob.X > n) then \r\n    { blob with X = n - (blob.X - n); vx = -blob.vx }\r\n  else blob\r\n\r\n/// Move blob by one step - adds X and Y \r\n/// velocities to the X and Y coordinates\r\nlet move (blob:Blob) =\r\n  { blob with \r\n      X = blob.X + blob.vx\r\n      Y = max 0.0 (blob.Y + blob.vy) }\r\n(**\r\nThe above functions capture the individual aspects of the movement. The\r\nfollowing put everything together and handle steps of Player's blob and\r\nalso collision detection.\r\n*)\r\n/// Apply step on Player's blob. Composes above functions.\r\nlet step dir blob =\r\n  blob |> direct dir |> move |> bounce\r\n\r\n/// Check whether two blobs collide\r\nlet collide (a:Blob) (b:Blob) =\r\n  let dx = (a.X - b.X)*(a.X - b.X)\r\n  let dy = (a.Y - b.Y)*(a.Y - b.Y)\r\n  let dist = sqrt(dx + dy)\r\n  dist < abs(a.Radius - b.Radius)\r\n\r\n/// Remove all falling blobs that hit Player's blob\r\nlet absorb (blob:Blob) (drops:Blob list) =\r\n  drops |> List.filter (fun drop ->\r\n    collide blob drop |> not )\r\n(** \r\n## Game logic helpers\r\n\r\nNext, we define a couple of helpers for generating and updating the falling blobs.\r\nWe have black growing blobs and white shrinking blobs. The `newGrow` and `newShrink`\r\nfunctions are used to generate new blobs:\r\n*)\r\nlet grow = \"black\"\r\nlet shrink = \"white\"\r\n\r\nlet newDrop color = \r\n  { X = rand()*width*0.8 + (width*0.1) \r\n    Y=600.; Radius=10.; vx=0.; vy = 0.0\r\n    color=color }\r\n\r\nlet newGrow () = newDrop grow\r\nlet newShrink () = newDrop shrink\r\n(**\r\nInside the game loop, we will generate blobs randomly, but we keep a counter of\r\nticks to make sure that we do not generate new blobs too often. The `updateDrops`\r\nfunction takes current drops and a countdown and returns a pair with new drops and\r\na new countdown. It implements simple logic:\r\n\r\n - If we generated drop in last 8 steps, do nothing and decrement counter\r\n - Roll an 8 sided dice and if we get 1, generate new blob \r\n   (2/3 are shrinkind and 1/3 are growing)\r\n - Otherwise, do nothing and return previous state\r\n\r\n*)\r\n/// Update drops and countdown in each step\r\nlet updateDrops drops countdown = \r\n  if countdown > 0 then \r\n    drops, countdown - 1\r\n  elif floor(rand()*8.) = 0. then\r\n    let drop = \r\n      if floor(rand()*3.) = 0. then newGrow() \r\n      else newShrink()\r\n    drop::drops, 8\r\n  else drops, countdown\r\n\r\n/// Count growing and shrinking drops in the list\r\nlet countDrops drops = \r\n  let count color =\r\n    drops \r\n    |> List.filter (fun drop -> drop.color = color) \r\n    |> List.length\r\n  count grow, count shrink\r\n\r\n(**\r\n## Asynchronous game loop\r\n\r\nThe asynchronous game loop is perhaps the most interesting part of the source code.\r\nFable supports F# asynchronous workflows, which give us a way to write non-blocking loop\r\nthat includes sleeping in the middle, so you can write long-running processes as a recursive\r\nloop rather than using timers and callbacks.\r\n\r\nThe following diagram illustrates the game loop:\r\n\r\n    [lang=text]\r\n    (start)        +----(tick)---+\r\n       \\           |             |\r\n         +------+  |  +--------+ |   +-----------+\r\n      +->| game |--+->| update |-+-->| completed |<-+\r\n      |  +------+     +--------+     +-----------+  |\r\n      |                                             |\r\n      +-----------(after 10 seconds)----------------+\r\n\r\nThere are three states in which the game can be:\r\n\r\n - After starting, the `game` state initializes the Player's blob and starts the game\r\n - The `update` loop is active when the game is running. It calls itself recursively\r\n   until the game ends.\r\n - After finishing, the `completed` state displays a message and sleeps for 10 seconds\r\n   before starting a new game.\r\n   \r\nUsing asynchronous workflows, the state machine can be represented using 3 mutually\r\nrecursive functions, each representing one of the states. The `game` and `completed`\r\nstates are simple:\r\n*)\r\n/// Starts a new game\r\nlet rec game () = async {\r\n  let blob = \r\n    { X = 300.; Y=0.; Radius=50.; \r\n      vx=0.; vy=0.; color=\"black\" }\r\n  return! update blob [newGrow ()] 0 }\r\n\r\n/// Displays message and sleeps for 10 sec\r\nand completed () = async {\r\n  drawText (\"COMPLETED\",320.,300.)\r\n  do! Async.Sleep 10000\r\n  return! game () }\r\n(**\r\nNote that we are using `let rec .. and`, which lets us write multiple recursive functions\r\nthat can call each other. The `completed` function calls `game` after 10 seconds using\r\n`return!` (representing an asynchronous tail-call) and the `game` function calls `update`\r\nwith the initial state. The `update` loop looks as follows:\r\n*)\r\n/// Keeps current state for Player's blob, falling\r\n/// drops and the countdown since last drop was generated\r\nand update blob drops countdown = async {\r\n  // Update the drops & countdown\r\n  let drops, countdown = updateDrops drops countdown\r\n\r\n  // Count drops, apply physics and count them again\r\n  let beforeGrow, beforeShrink = countDrops drops\r\n  let drops = \r\n    drops \r\n    |> List.map (gravity >> move) \r\n    |> absorb blob\r\n  let afterGrow, afterShrink = countDrops drops\r\n  let drops = drops |> List.filter (fun blob -> blob.Y > 0.)\r\n\r\n  // Calculate new player's size based on absorbed drops\r\n  let radius = blob.Radius + float (beforeGrow - afterGrow) *4.\r\n  let radius = radius - float (beforeShrink - afterShrink) * 4.\r\n  let radius = max 5.0 radius\r\n\r\n  // Update radius and apply keyboard events\r\n  let blob = { blob with Radius = radius }   \r\n  let blob = blob |> step (Keyboard.arrows())\r\n\r\n  // Render the new game state\r\n  drawBg ctx canvas\r\n  for drop in drops do drawBlob ctx canvas drop\r\n  drawBlob ctx canvas blob\r\n\r\n  // If the game completed, switch state\r\n  // otherwise sleep and update recursively!\r\n  if blob.Radius > 150. then \r\n    return! completed()\r\n  else \r\n    do! Async.Sleep(int (1000. / 60.))\r\n    return! update blob drops countdown }\r\n(** \r\nThe last thing that we need to do is to start the game in the initial `game`\r\nstate using `Async.StartImmediate`:\r\n*)\r\ngame () |> Async.StartImmediate\r\n"]}