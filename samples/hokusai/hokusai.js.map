{"version":3,"sources":["../samples/browser/hokusai/hokusai.fsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCK;AAhCL;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAgCK;AAAA;AAAA,iCAGe;AAAA;AAAA,yEACC,WADD,EACQ,WADR,mDAEZ,WAAJ,WACa,WADb,EAEE,OAAO,UAAK,IAAM,WAAX,CAFT,IAGK,UAAL,kBAGa,WAHb,EAIE,OAAO,UAAK,IAAM,WAAX,CAJT,CALgB;AAAa;AAH5B;AAAA;AAAA,gDAcgB;AAAA;AAAA,uGACjB,uBAAQ,OAAR,EAAe,OAAf,CADiB;AAAe;AAd/B;;AAAA;AAAA;;AAoBE;AAED,6BAAI;AAAA;AAAA,6DACI,YAAY,4BAAZ,CADJ,SAEK,gBAFL,SAGK,YAHL,SAIK,oBAJL,EAKN,uBAAQ,OAAO,cAAf,EAA0B,OAAO,cAAjC,CALM;AAAa,KAAjB;;AAFC;AAEE,GAFF;;AAiBH,sBAAI,yCAAJ;;AAGA,kCACF;AAAA;AAAA,kBACE;AAAA;AAAA,wEACA;AAAA,sBAAa,qDAAb;AAAiD,SAAjD,CADA;AAAa,OAAb;AAAa,KADf,EAGA,KAAM,4BAAN,CAHA;AAGoB,GAJlB;;AAWA,kDACF;AAAA,0DAE2B;AAAA;AAAoB,KAF/C,sBACa,OADb;AAGa,GAJX;;AAgBC;AAAA;AAAA;;AACA,4DAAO;AAAA;AAAA,wDAA+B,sBACzC;AAAA,gCACM;AAAA;AAAA,mBAAI,WAAJ,QAED;AAAA;AAAA,wBAAW,CAAC,OAAD,KAAX;AAAwC,WAAxC;AAAwC,SAFvC,GAGH,WAHG,EAGQ,WAHR,EAGmB,WAHnB;AAAC,OADP,EAAS,wBAAK,SAAL,CAAT;AAImC,KAJnC,CADyC,CAA/B;AAAQ,GAAf;;AAUD,kCACF,WACG;AAAA;AAAA,8CAAO,iCAAP,6IAAO,+CAAP,GACA;AAAA;AAAA,gDAAO,iCAAP,6IAAO,+CAAP,GAEA;AAAA;AAAA,kDAAO,iCAAP,yIAAO,+CAAP,GACA;AAAA;AAAA,oDAAO,6BAAP,4IAAO,+CAAP,GAEA;AAAA;AAAA,sDAAO,gCAAP,6IAAO,+CAAP,GACA;AAAA;AAAA,wDAAO,kCAAP,6IAAO,+CAAP,GACA,qBAAO;AAAA;AAAA;AAAkC,eAAzC,CADA;AAA0C,aAA1C,CADA;AAA0C,WAA1C,CAFA;AAAwC,SAAxC,CADA;AAAqC,OAArC,CAFA;AAAyC,KAAzC,CADA;AAAyC,GAAzC,CADH,CADE;AAqBA;AACA;AAGA;AACA;;AAOA,oCACE;AAAQ,iBAAC,IAAI,IAAI,mBAAT;AAAR,aACa,SADb;AAAA,aAEa,SAFb;AAAA,aAGa,SAHb;AAAA,aAIa,SAJb;AAAK,GADP;;AAQC,wCACH;AAAA;AAAwB,GADrB;;AAQD,gCAAY;AAAA;AAAA,4BAEV;AAAA;AAAA,sBAA2B,8BAA3B,qCAEM,kCAFN,EAMJ,aAAS,wBAAK,qBAAL,CAAT;AAAA;AAAA,4BACE,8BAAS,wBAAK,sBAAL,CAAT;AAAA;AAAA,mCACY,aAAmB,WAAnB,CAAD,OADX,OAEY,cAAoB,WAApB,CAAD,OAFX,OAGW,uCAHX,kFAIE,mCAJF,GAIE,eAJF;AAA+B,WAA/B,kBAOA;AAAA,iCAAI,yBAAJ,EACA;AAAA;AAA+B,aAD/B;AAAkB,WAPlB,EADF;AAA8B,SAA9B,CANI;AAAI,OAFM;AAAK,KAAL;AAAK,GAAjB;;AAwBA,wBAAyB,0BAAzB;+BAC0B;AAAA,WAChB;AAAA;AAAoB,KAAhC,UAD4B;AAAC,G","file":"hokusai.js","sourcesContent":["(**\r\n - title: Hokusai and factals\r\n - tagline: Rendering fractals using HTML5 canvas\r\n - app-style: padding:20px 0px 10px 0px;\r\n - intro: This demo is based on Tomas Petricek's [F# Advent Calendar post](http://tomasp.net/blog/2014/japan-advent-art-en/)\r\n   that explores Japenese art using the (now defunct) Freebase type provider and renders\r\n   The Great Wave by Hokusai using the Julia fractal.\r\n   You can find the [full source code on GitHub](https://github.com/fsprojects/Fable/blob/master/samples/browser/hokusai/hokusai.fsx).\r\n\r\n   In this demo, you'll see how to define a simple complex number arithmetic in F#,\r\n   how to use it to implement the Julia set fractal and how to render the fractal\r\n   asynchronously to avoid blocking the browser during the process.\r\n   To run the demo, click the \"Render Julia set fractal\" button!\r\n\r\n*)\r\n(*** hide ***)\r\n#r \"node_modules/fable-core/Fable.Core.dll\"\r\n\r\nopen Fable.Core\r\nopen Fable.Import.Browser\r\n\r\n(**\r\nComplex numbers\r\n---------------\r\n\r\nBefore looking at the fractal, we need a simple type for working with\r\ncomplex numbers that supports the `+` operation and the `abs` and `pow` functions.\r\nWe define the type as a simple wrapper over a pair of floating point numbers and\r\nadd `Abs` and `+` as static methods. This way, they can be used through the usual\r\nF# functions:\r\n*)\r\n\r\ntype Complex =\r\n  | Complex of float * float\r\n  /// Calculate the absolute value of a complex number\r\n  static member Abs(Complex(r, i)) =\r\n    let num1, num2 = abs r, abs i\r\n    if (num1 > num2) then\r\n      let num3 = num2 / num1\r\n      num1 * sqrt(1.0 + num3 * num3)\r\n    elif num2 = 0.0 then\r\n      num1\r\n    else\r\n      let num4 = num1 / num2\r\n      num2 * sqrt(1.0 + num4 * num4)\r\n  /// Add real and imaginary components pointwise\r\n  static member (+) (Complex(r1, i1), Complex(r2, i2)) =\r\n    Complex(r1+r2, i1+i2)\r\n(**\r\nBefore moving forward, we also need to calculate a power of complex numbers.\r\nTo do this, we define a `Pow` function in a helper module:\r\n*)\r\nmodule ComplexModule =\r\n  /// Calculates nth power of a complex number\r\n  let Pow(Complex(r, i), power) =\r\n    let num = Complex.Abs(Complex(r, i))\r\n    let num2 = atan2 i r\r\n    let num3 = power * num2\r\n    let num4 = num ** power\r\n    Complex(num4 * cos(num3), num4 * sin(num3))\r\n(**\r\nCalculating the Julia set\r\n-------------------------\r\n\r\nNow we have all we need to calculate the Julia set fractal. We choose\r\na carefuly chosen (handcrafted!) starting point. Then we create a sequence\r\nof powers using F# sequence expressions:\r\n*)\r\n/// Constant that generates nice fractal\r\nlet c = Complex(-0.70176, -0.3842)\r\n\r\n/// Generates sequence for given coordinates\r\nlet iterate x y =\r\n  let rec loop current = seq {\r\n    yield current\r\n    yield! loop (ComplexModule.Pow(current, 2.0) + c) }\r\n  loop (Complex(x, y))\r\n(**\r\nThe `iterate` lazilly function generates potentially infinite sequence of\r\nvalues. We take at most `max` iterations or stop when the absolute value of\r\nthe number is greater than 2. This can be nicely written using `Seq` functions\r\nfrom the standard F# library (supported by Fable):\r\n*)\r\nlet countIterations max x y =\r\n  iterate x y\r\n  |> Seq.take (max - 1)\r\n  |> Seq.takeWhile (fun v -> Complex.Abs(v) < 2.0)\r\n  |> Seq.length\r\n(**\r\nGenerating the color palette\r\n----------------------------\r\n\r\nTo generate a pretty picture, we need to carefuly generate the color palette.\r\nTO do this, we define a pair of operators that let us write\r\n`(rgb1) --n--> (rbg2)` and generate a range of colors between `rgb1` and `rgb2`\r\nconsisting of `n` steps.\r\n*)\r\n\r\n// Transition between colors in 'count' steps\r\nlet (--) clr count = clr, count\r\nlet (-->) ((r1,g1,b1), count) (r2,g2,b2) = [\r\n  for c in 0 .. count - 1 ->\r\n    let k = float c / float count\r\n    let mid v1 v2 =\r\n      (float v1 + ((float v2) - (float v1)) * k)\r\n    (mid r1 r2, mid g1 g2, mid b1 b2) ]\r\n(**\r\nNow we can generate palette that is based on Hokusai's famous painting:\r\n*)\r\n// Palette with colors used by Hokusai\r\nlet palette =\r\n  [| // 3x sky color & transition to light blue\r\n     yield! (245,219,184) --3--> (245,219,184)\r\n     yield! (245,219,184) --4--> (138,173,179)\r\n     // to dark blue and then medium dark blue\r\n     yield! (138,173,179) --4--> (2,12,74)\r\n     yield! (2,12,74)     --4--> (61,102,130)\r\n     // to wave color, then light blue & back to wave\r\n     yield! (61,102,130)  -- 8--> (249,243,221)\r\n     yield! (249,243,221) --32--> (138,173,179)\r\n     yield! (138,173,179) --32--> (61,102,130) |]\r\n\r\n(**\r\nDrawing the fractal\r\n-------------------\r\nThe last step is to render the fractal. To do that, we first define a couple of constants\r\nand helpers. The following constants define what part of the fractal we're rendering and\r\nhow big is the canvas:\r\n*)\r\n\r\n// Specifies what range of the set to draw\r\nlet w = -0.4, 0.4\r\nlet h = -0.95, -0.35\r\n\r\n// Create bitmap that matches the size of the canvas\r\nlet width = 400.0\r\nlet height = 300.0\r\n(**\r\nNext, we define `setPixel` that sets the RGBA colours of a specified pixel in the canvas\r\nand we'll use F# dynamic operator so that `doc?canvas` returns an HTML element with ID\r\n`canvas`:\r\n*)\r\n/// Set pixel value in ImageData to a given color\r\nlet setPixel (img:ImageData) x y width (r, g, b) =\r\n  let index = (x + y * int width) * 4\r\n  img.data.[float (index+0)] <- r\r\n  img.data.[float (index+1)] <- g\r\n  img.data.[float (index+2)] <- b\r\n  img.data.[float (index+3)] <- 255.0\r\n\r\n/// Dynamic operator that returns HTML element by ID\r\nlet (?) (doc:Document) name :'R =\r\n  doc.getElementById(name) :?> 'R\r\n(**\r\nThe rendering itself is written as an F# asynchronous workflow. The workflow sleeps for\r\n1ms after rendering each line of the fractal. Behind the scenes, this unblocks the window\r\nvia a timer, so that the JavaScript function call does not block the browser while running.\r\n*)\r\n/// Render fractal asynchronously with sleep after every line\r\nlet render () = async {\r\n  // Get <canvas> element & create image for drawing\r\n  let canv : HTMLCanvasElement = document?canvas\r\n  let ctx = canv.getContext_2d()\r\n  let img = ctx.createImageData(U2.Case1 (float width), float height)\r\n\r\n  // For each pixel, transform to the specified range\r\n  // and get color using countInterations and palette\r\n  for x in 0 .. int width - 1 do\r\n    for y in 0 .. int height - 1 do\r\n      let x' = (float x / width * (snd w - fst w)) + fst w\r\n      let y' = (float y / height * (snd h - fst h)) + fst h\r\n      let it = countIterations palette.Length x' y'\r\n      setPixel img x y width palette.[it]\r\n\r\n    // Insert non-blocking waiting & update the fractal\r\n    do! Async.Sleep(1)\r\n    ctx.putImageData(img, 0.0, 0.0) }\r\n(**\r\nNow we just need to register the event handler for the `go` button and start the\r\nasynchronous workflow to do the rendering. Note that this is done using `Async.StartImmediate`:\r\n*)\r\n/// Setup button event handler to start the rendering\r\n\r\nlet go : HTMLButtonElement = document?go\r\ngo.addEventListener_click(fun _ ->\r\n  render() |> Async.StartImmediate; null)\r\n"]}