{"version":3,"sources":["../samples/browser/pacman/pacman.fsx"],"names":[],"mappings":"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","file":"pacman.js","sourcesContent":["(**\r\n - title: Pacman game\r\n - tagline: Pacman finds himself in a grid filled with monsters...\r\n - app-style: height:300px; width:300px; margin:20px auto 20px auto; position:relative;\r\n - intro: Pacman finds himself in a grid filled with monsters... This is probably the most complex sample here.\n   It involves rendering the maze, AI for the ghosts, user interaction and even playing sound effects.\n   The game has some brief commentary, but if you want to learn Fable, look at the above examples\n   first. The [raw source code is on GitHub](https://github.com/fsprojects/Fable/blob/master/samples/browser/pacman/pacman.fsx)\n   as usual!\n\n   To play the game, click anywhere to start it and then use the `Z` and `X` keys for moving left and right\n   and the `Q` and `A` keys for moving up and down. Make sure to turn on your volume too :-).\n\r\n*)\r\n(*** hide ***)\r\n#r \"node_modules/fable-core/Fable.Core.dll\"\r\n\r\nopen Fable.Core\r\nopen Fable.Import.Browser\r\n\r\nlet incr r = r := !r + 1\r\nlet decr r = r := !r - 1\r\nlet min a b = if a > b then b else a\r\nlet max a b = if a > b then a else b\r\n\r\n[<Emit(\"Math.random()\")>]\r\nlet random (): float = failwith \"JS only\"\r\n(**\r\nThis is a full blown Pacman game. If you're looking for an introduction to Fable\r\nthen visit other tutorials, in particular the [Mario game](../mario/index.html) which\r\nis much simpler.\r\n\r\n## Implementing the maze\r\n\r\n### Loading maze and graphics\r\n\r\nSome of the graphics, maze structure and walls are defined as embedded strings or\r\narrays in the following section, so that the game is stand-alone and easily portable.\r\n\r\nThe following block embeds the ghosts and other parts of graphics as Base64 encoded strings.\r\nThis way, we can load them without making additional server requests:\r\n*)\r\n\r\nlet cyand = (*[omit:\"data:image/png;base64,iVBOR...\"]*)\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAiUlEQVQoU8WSURKAIAhE8Sh6Fc/tVfQoJdqiMDTVV4wfufAAmw3kxEHUz4pA1I8OJVjAKZZ6+XiC0ATTB/gW2mEFtlpHLqaktrQ6TxUQSRCAPX2AWPMLyM0VmPOcV8palxt6uoAMpDjfWJt+o6cr0DPDnfYjyL94NwIcYjXcR/FuYklcxrZ3OO0Ep4dJ/3dR5jcAAAAASUVORK5CYII=\"(*[/omit]*)\r\nlet oranged = (*[omit:\"data:image/png;base64,iVBOR...\"]*)\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAgklEQVQoU8WS0RGAIAxDZRRYhblZBUZBsBSaUk/9kj9CXlru4g7r1FxBdsFpGwoa2NwrYIFPEIeM6QS+hQQMYC70EjzuuOlt6gT5kRGGTf0Cx5qfwJYOYIw0L6W1bg+09Al2wAcCS8Y/WjqAZhluxD/B3ghZBO6n1sadzLLEbNSg8pzXIVLvbNvPwAAAAABJRU5ErkJggg==\"(*[/omit]*)\r\n(*[omit:(Other images omitted)]*)\r\nlet pinkd = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAj0lEQVQoU8WSsRWAIAxEZRQpXITGVZzIVWxYxAJHwRfwMInxqZV0XPIvgXeuM05eUuayG73TbULQwKWZGTTwCYIJphfwLcRhAW5DLfWrXFLrNLWBKAIBbOkFxJpfQDIXYAh1XoznumRo6Q0kwE8VTLN8o6UL0ArDnfYjSF/Mg4CEaA330sxD3ApHLvUdSdsBdgNkr9L8gxYAAAAASUVORK5CYII=\"\r\nlet redd = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAkklEQVQoU8WSvRWAIAyEZRQtXIRCV3EiVtGCRSx0FHxBD5MYn1pJl0u+/PDOVcZLY5e47PrJ6TIhaOBSzBoU8AlCE0zP4FuIwwJc25Bz9TyILbVOUwuIJAjAlp5BrPkFpOYC9H6fF+O5LjW09AIS0Az7jUuQN1q6AC0z3Gk/gvTF3AhwiNYQ52Ju4pI4fKljOG0DA3tp97vN6C8AAAAASUVORK5CYII=\"\r\nlet pu1 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAWElEQVQoU62SUQoAIAhD9f6HNiYYolYi9VfzuXIxDRYbI0LCTHsfe3ldi3BgRRUY9Rnku1Rupf4NgiPeVjVU7STckphBceSvrHHtNPI21HWz4NO3eUUAgwVpmjX/zwK8KQAAAABJRU5ErkJggg==\"\r\nlet pu2 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAW0lEQVQoU8WSwQoAIAhD9f8/2lIwdKRIl7o1e010THBESJiJXca76qnoDxFC3SD9LRpWkLnsLt4gdImtlLX/EK4iDapqr4VuI2+BauQjaOrmSz8xillDp5gQrS054jv/0fkNVAAAAABJRU5ErkJggg==\"\r\nlet pd1 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAXElEQVQoU62SUQoAIAhD9f6HNgyMWpMs6k/XU5mqwDMTw5yq6JwbAfucwR2qAFHAu75BN11Gt6+Qz54VpMJsMV3BaS9UR8txkUzfLC9DUY0BYbOPGfpyU3g2WdwAOvU1/9KZsT4AAAAASUVORK5CYII=\"\r\nlet pd2 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAU0lEQVQoU62SUQoAIAhD9f6HNgwUGw4s6q/pc6KqwDMTQ01VtGr56ZIZvKEJEAXc9Q26cUm3r5D3zgrywHeoG3ldJrZIRz6C0I1BoR83FTBCeHsLIlw7/wOkQycAAAAASUVORK5CYII=\"\r\nlet pl1 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAVUlEQVQoU62S2woAIAhD9f8/2jAwvGRMyDfF49iQKZUISZ4xE/vZaW7LHbwhBLADqjpSUjBAdglRDQa9hxfcQi+vf5RGnpDlkB4KlMgR0N6pBIH83gIPFCb/N+MLCwAAAABJRU5ErkJggg==\"\r\nlet pl2 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAUklEQVQoU52SUQoAIAhD3f0PbRQoZgnT/hyttYeQdFRFswYIoubD73JlPibGYA/s1Jmpk+JpDIinWxbiXP3iQslCwbhTxzhHbsWZNFsnCkTevQW2bCb/VRTuVwAAAABJRU5ErkJggg==\"\r\nlet pr1 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAWElEQVQoU52S4Q4AIASE3fs/tKalSTHyL/O5CyAXzMQ+BxBsbj9exRE8oQqgDUS1BalNVFSuP2WQL94WIygCBEzttZWOvbz2VBnGtLXg1sgV/L8I679yewN9sScO5wcxLQAAAABJRU5ErkJggg==\"\r\nlet pr2 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA0AAAANCAYAAABy6+R8AAAAVElEQVQoU62SWwoAIAgE9f6HNgqU3BK2R3+J48KoCjwzMaypis61+OyaK3hADOADeuoddJISaQy0iKggbEz2viah7mVPTNq7cp/ApLmcdFPVdaDJBnWdJwjk629HAAAAAElFTkSuQmCC\"\r\nlet blue = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAeklEQVQoU62S0Q3AIAhEyyi6UcfoRB2jG+koNkeCoVcaTaw/huMeEkS24KTUmpdrFWHbQ2CAzb5AB0eQFTFYwVnIw/+B5by0cD52vTmGhnaF25wBAb/A6HsibR0ctch5fRHi1zCigvCut4oR+wnbhrBmsZr9DlqCQfbcnfZjDyiZqCEAAAAASUVORK5CYII=\"\r\nlet eyed = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAUElEQVQoU2NkIBMwkqmPYYA13rt37z/I6UpKSiguwSYOVwCThPkZphmXOHU0OjtD7Nu7F+FckI3YxFH8oqgI8eP9+6h+xCY+wNFBSiqiv1MBDgYsD185vj8AAAAASUVORK5CYII=\"\r\nlet _200 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAS0lEQVQoU2NkIBMwkqmPYYA0vpVR+Q9zsvCTO4yE+CC1KE4FaYBpxEfDNWKzgWiNIIUw5xKyGa+N+PyM4UdS4nSA4pEUJ8LUku1UAMC0VA8iscBNAAAAAElFTkSuQmCC\"\r\nlet _400 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAASElEQVQoU2NkIBMwkqmPYYA0vpVR+S/85A4jMg3zAkwcmQ9ig52KTSO6Qch8FI3oNhClEaaJWJvhNmLTSJQfyYnLAYpHujoVAChTXA9pVJi5AAAAAElFTkSuQmCC\"\r\nlet _800 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAQElEQVQoU2NkIBMwkqmPYYA0vpVR+Q9zsvCTO4yE+CC1YKeCFMI0EEOjaES3EZ8BtLERn5/hNpITlwMUj3R1KgCe5lwPHtUmcwAAAABJRU5ErkJggg==\"\r\nlet _1600 = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAA4AAAAOCAYAAAAfSC3RAAAAQ0lEQVQoU2NkIBMwkqmPYQA0vpVR+S/85A4jiIY5mxg+WANMIYiGaUYXR+ejaES3EdlAvBrxKSTJRnx+HoDoGDopBwDHLGwPAhDgRQAAAABJRU5ErkJggg==\"\r\n(*[/omit]*)\r\n\r\n// Create image using the specified data\r\nlet createImage data =\r\n  let img = document.createElement_img()\r\n  img.src <- data\r\n  img\r\n(**\r\nThe second part defines the maze, tile bits and blank block. The maze is defined as one big string\r\nusing ASCII-art encoding. Where `/7LJ` represent corners (upper-left, upper-right, lower-left and lower-right),\r\n`!|-_` represent walls (left, right, top, bottom)` and `o.` represent two kinds of pills in the maze.\r\n*)\r\n// Define the structure of the maze using ASCII\r\nlet maze = \r\n  (*[omit:\"##|./__7./___7.|!./___7./__7.|##,\"...]*)\r\n  (\"\\\r\n##/------------7/------------7##,\\\r\n##|............|!............|##,\\\r\n##|./__7./___7.|!./___7./__7.|##,\\\r\n##|o|  !.|   !.|!.|   !.|  !o|##,\\\r\n##|.L--J.L---J.LJ.L---J.L--J.|##,\\\r\n##|..........................|##,\\\r\n##|./__7./7./______7./7./__7.|##,\\\r\n##|.L--J.|!.L--7/--J.|!.L--J.|##,\\\r\n##|......|!....|!....|!......|##,\\\r\n##L____7.|L__7 |! /__J!./____J##,\\\r\n#######!.|/--J LJ L--7!.|#######,\\\r\n#######!.|!          |!.|#######,\\\r\n#######!.|! /__==__7 |!.|#######,\\\r\n-------J.LJ |      ! LJ.L-------,\\\r\n########.   | **** !   .########,\\\r\n_______7./7 |      ! /7./_______,\\\r\n#######!.|! L______J |!.|#######,\\\r\n#######!.|!          |!.|#######,\\\r\n#######!.|! /______7 |!.|#######,\\\r\n##/----J.LJ L--7/--J LJ.L----7##,\\\r\n##|............|!............|##,\\\r\n##|./__7./___7.|!./___7./__7.|##,\\\r\n##|.L-7!.L---J.LJ.L---J.|/-J.|##,\\\r\n##|o..|!.......<>.......|!..o|##,\\\r\n##L_7.|!./7./______7./7.|!./_J##,\\\r\n##/-J.LJ.|!.L--7/--J.|!.LJ.L-7##,\\\r\n##|......|!....|!....|!......|##,\\\r\n##|./____JL__7.|!./__JL____7.|##,\\\r\n##|.L--------J.LJ.L--------J.|##,\\\r\n##|..........................|##,\\\r\n##L--------------------------J##\").Split(',') (*[/omit]*)\r\n\r\nlet tileBits = \r\n [| [|0b00000000;0b00000000;0b00000000;\r\n      0b00000000;0b00000011;0b00000100;\r\n      0b00001000;0b00001000|] \r\n    (*[omit:[|0b00000000;0b00000000;...]*) // tl\r\n    [|0b00000000;0b00000000;0b00000000;0b00000000;0b11111111;0b00000000;0b00000000;0b00000000|] // top\r\n    [|0b00000000;0b00000000;0b00000000;0b00000000;0b11000000;0b00100000;0b00010000;0b00010000|] // tr\r\n    [|0b00001000;0b00001000;0b00001000;0b00001000;0b00001000;0b00001000;0b00001000;0b00001000|] // left\r\n    [|0b00010000;0b00010000;0b00010000;0b00010000;0b00010000;0b00010000;0b00010000;0b00010000|] // right\r\n    [|0b00001000;0b00001000;0b00000100;0b00000011;0b00000000;0b00000000;0b00000000;0b00000000|] // bl\r\n    [|0b00000000;0b00000000;0b00000000;0b11111111;0b00000000;0b00000000;0b00000000;0b00000000|] // bottom\r\n    [|0b00010000;0b00010000;0b00100000;0b11000000;0b00000000;0b00000000;0b00000000;0b00000000|] // br\r\n    [|0b00000000;0b00000000;0b00000000;0b00000000;0b11111111;0b00000000;0b00000000;0b00000000|] // door\r\n    [|0b00000000;0b00000000;0b00000000;0b00011000;0b00011000;0b00000000;0b00000000;0b00000000|] // pill\r\n    [|0b00000000;0b00011000;0b00111100;0b01111110;0b01111110;0b00111100;0b00011000;0b00000000|] // power\r\n  (*[/omit]*) |]\r\n\r\nlet blank = \r\n  [| 0b00000000;0b00000000;0b00000000;\r\n     (*[omit:0b00000000;0b00000000; ...]*) 0b00000000;0b00000000;0b00000000;0b00000000;0b00000000 (*[/omit]*)|]\r\n(**\r\n### Checking for walls\r\n\r\nThe following functions parse the maze representation and check various properties of the maze.\r\nThose are used for rendering, but also for checking whether Pacman can go in a given direction.\r\n*)\r\n/// Characters _|!/7LJ represent different walls\r\nlet isWall (c:char) = \r\n  \"_|!/7LJ-\".IndexOf(c) <> -1\r\n\r\n/// Returns ' ' for positions outside of range\r\nlet tileAt (x,y) = \r\n  if x < 0 || x > 30 then ' ' else maze.[y].[x]\r\n\r\n/// Is the maze tile at x,y a wall?\r\nlet isWallAt (x,y) = \r\n  tileAt(x,y) |> isWall\r\n\r\n// Is Pacman at a point where it can turn?\r\nlet verticallyAligned (x,y) =  (x % 8) = 5\r\nlet horizontallyAligned (x,y) = (y % 8) = 5\r\nlet isAligned n = (n % 8) = 5\r\n\r\n// Check whether Pacman can go in given direction\r\nlet noWall (x,y) (ex,ey) =\r\n  let bx, by = (x+6+ex) >>> 3, (y+6+ey) >>> 3\r\n  isWallAt (bx,by) |> not\r\n\r\nlet canGoUp (x,y) = isAligned x && noWall (x,y) (0,-4)\r\nlet canGoDown (x,y) = isAligned x && noWall (x,y) (0,5)\r\nlet canGoLeft (x,y) = isAligned y && noWall (x,y) (-4,0)\r\nlet canGoRight (x,y) = isAligned y && noWall (x,y) (5,0)\r\n\r\n(**\r\n### Background rendering\r\n\r\nTo render the background, we first fill the background\r\nand then iterate over the string lines that represent the maze and we draw images of\r\nwalls specified in the `tileBits` value earlier (or use `blank` tile for all other characters).\r\n\r\nThe following is used to map from tile characters to the `tileBits` values and to draw individual lines:\r\n*)\r\n// Mapping from Maze walls to tileBits\r\nlet tileColors = \"BBBBBBBBBYY\"\r\nlet tileChars =  \"/_7|!L-J=.o\"\r\n\r\n/// Returns tile for a given Maze character\r\nlet toTile (c:char) =\r\n  let i = tileChars.IndexOf(c)\r\n  if i = -1 then blank, 'B'\r\n  else tileBits.[i], tileColors.[i]\r\n\r\n/// Draw the lines specified by a wall tile\r\nlet draw f (lines:int[]) =\r\n  let width = 8\r\n  lines |> Array.iteri (fun y line ->\r\n    for x = 0 to width-1 do\r\n      let bit = (1 <<< (width - 1 - x))\r\n      let pattern = line &&& bit\r\n      if pattern <> 0 then f (x,y) )\r\n\r\n/// Creates a brush for rendering the given RGBA color\r\nlet createBrush (context:CanvasRenderingContext2D) (r,g,b,a) =\r\n  let id = context.createImageData(U2.Case1 1.0, 1.0)\r\n  let d = id.data\r\n  d.[0.] <- float r; d.[1.] <- float g\r\n  d.[2.] <- float b; d.[3.] <- float a\r\n  id\r\n(**\r\nThe main function for rendering background just fills the canvas with a black color and\r\nthen iterates over the Maze tiles and renders individual walls:\r\n*)\r\n\r\nlet createBackground () =\r\n  // Fill background with black\r\n  let background = document.createElement_canvas()\r\n  background.width <- 256.\r\n  background.height <- 256.\r\n  let context = background.getContext_2d()\r\n  context.fillStyle <- U3.Case1 \"rgb(0,0,0)\"\r\n  context.fillRect (0., 0. , 256., 256.);\r\n\r\n  // Render individual tiles of the maze\r\n  let blue = createBrush context (63,63,255,255)\r\n  let yellow = createBrush context (255,255,0,255)\r\n  let lines = maze\r\n  for y = 0 to lines.Length-1 do\r\n    let line = lines.[y]\r\n    for x = 0 to line.Length-1 do\r\n      let c = line.[x]\r\n      let tile, color = toTile c\r\n      let brush = match color with 'Y' -> yellow | _ -> blue\r\n      let f (x',y') =\r\n        context.putImageData\r\n          (brush, float (x*8 + x'), float (y*8 + y'))\r\n      draw f tile\r\n  background\r\n\r\n/// Clear whatever is rendered in the specified Maze cell\r\nlet clearCell (background : HTMLCanvasElement) (x,y) =\r\n  let context = background.getContext_2d()\r\n  context.fillStyle <- U3.Case1 \"rgb(0,0,0)\"\r\n  context.fillRect (float (x*8), float (y*8), 8., 8.);\r\n\r\n(**\r\n## Creating smart ghosts\r\n\r\n### Creating ghosts\r\n\r\nGhosts are represented by a simple F# class type that contains the image of the ghost,\r\ncurrent X, Y positions and a velocity in both directions. In Pacman, ghosts are mutable\r\nand expose `Move` and `Reset` methods that change their properties.\r\n*)\r\n\r\n/// Wrap around the sides of the Maze\r\nlet wrap (x,y) (dx,dy) =\r\n  let x =\r\n    if dx = -1 && x = 0 then 30 * 8\r\n    elif dx = 1  && x = 30 *8 then 0\r\n    else x\r\n  x + dx, y + dy\r\n\r\n/// Mutable representation of a ghost\r\ntype Ghost(image:HTMLImageElement,x,y,v) =\r\n  let mutable x' = x\r\n  let mutable y' = y\r\n  let mutable v' = v\r\n  member val Image = image\r\n  member val IsReturning = false with get, set\r\n  member __.X = x'\r\n  member __.Y = y'\r\n  member __.V = v'\r\n  /// Move back to initial location\r\n  member ghost.Reset() =\r\n    x' <- x\r\n    y' <- y\r\n  /// Move in the current direction\r\n  member ghost.Move(v) =\r\n    v' <- v\r\n    let dx,dy = v\r\n    let x,y = wrap (x',y') (dx,dy)\r\n    x' <- x\r\n    y' <- y\r\n(**\r\nAt the beginning, we have red, cyan, pink and orange ghosts\r\nin the middle of the maze:\r\n*)\r\nlet createGhosts context =\r\n  [| redd, (16, 11), (1,0)\r\n     cyand, (14, 15), (1,0)\r\n     pinkd, (16, 13), (0,-1)\r\n     oranged, (18, 15), (-1,0) |]\r\n  |> Array.map (fun (data,(x,y),v) ->\r\n    Ghost(createImage data, (x*8)-7, (y*8)-3, v) )\r\n\r\n(**\r\n### Generating Ghost movement\r\n\r\nFor generating Ghost movements, we need an implementation of the [Flood fill algorithm](https://en.wikipedia.org/wiki/Flood_fill),\r\nwhich we use to generate the shortest path home when Ghosts are returning. The `fillValue` function does this, by starting\r\nat a specified location (which can be one of the directions in which ghosts can go).\r\n*)\r\n/// Recursive flood fill function\r\nlet flood canFill fill (x,y) =\r\n  let rec f n = function\r\n    | [] -> ()\r\n    | ps ->\r\n        let ps = ps |> List.filter (fun (x,y) -> canFill (x,y))\r\n        ps |> List.iter (fun (x,y) -> fill (x,y,n))\r\n        ps |> List.collect (fun (x,y) ->\r\n            [(x-1,y);(x+1,y);(x,y-1);(x,y+1)]) |> f (n+1)\r\n  f 0 [(x,y)]\r\n\r\n/// Possible routes that take the ghost home\r\nlet route_home =\r\n  let numbers =\r\n    maze |> Array.map (fun line ->\r\n      line.ToCharArray()\r\n      |> Array.map (fun c -> if isWall c then 999 else -1) )\r\n  let canFill (x:int,y:int) =\r\n    y>=0 && y < (numbers.Length-1) &&\r\n    x>=0 && x < (numbers.[y].Length-1) &&\r\n    numbers.[y].[x] = -1\r\n  let fill (x,y,n) = numbers.[y].[x] <- n\r\n  flood canFill fill (16,15)\r\n  numbers\r\n\r\n/// Find the shortest way home from specified location \r\n/// (adjusted by offset in which ghosts start)\r\nlet fillValue (x,y) (ex,ey) =\r\n  let bx = int (floor(float ((x+6+ex)/8)))\r\n  let by = int (floor(float ((y+6+ey)/8)))\r\n  route_home.[by].[bx]\r\n\r\nlet fillUp (x,y) = fillValue (x,y) (0,-4)\r\nlet fillDown (x,y) = fillValue (x,y) (0,5)\r\nlet fillLeft (x,y) = fillValue (x,y) (-4,0)\r\nlet fillRight (x,y) = fillValue (x,y) (5,0)\r\n(**\r\n\r\nWhen choosing a direction, ghosts that are returning will go in the direction\r\nthat leads them home. Other ghosts generate a list of possible directions (the `directions` array)\r\nand then filter those that are in the direction of Pacman and choose one of the options. If they\r\nare stuck and cannot go in any way, they stay where they are.\r\n*)\r\nlet chooseDirection (ghost:Ghost) =\r\n  let x,y = ghost.X, ghost.Y\r\n  let dx,dy = ghost.V\r\n  // Are we facing towards the given point?\r\n  let isBackwards (a,b) =\r\n    (a <> 0 && a = -dx) || (b <> 0 && b = -dy)\r\n  // Generate array with possible directions\r\n  let directions =\r\n    [|if canGoLeft(x,y) then yield (-1,0), fillLeft(x,y)\r\n      if canGoDown(x,y) then yield (0,1), fillDown(x,y)\r\n      if canGoRight(x,y) then yield (1,0), fillRight(x,y)\r\n      if canGoUp(x,y) then yield (0,-1), fillUp(x,y) |]\r\n\r\n  if ghost.IsReturning then\r\n    // Returning ghosts find the shortest way home\r\n    let xs = directions |> Array.sortBy snd\r\n    let v, n = xs.[0]\r\n    if n = 0 then ghost.IsReturning <- false\r\n    v\r\n  else\r\n    // Other ghosts pick one direction twoards Pacman\r\n    let xs = \r\n      directions\r\n      |> Array.map fst\r\n      |> Array.filter (not << isBackwards)\r\n    if xs.Length = 0 then 0, 0\r\n    else\r\n      let i = random() * float xs.Length\r\n      xs.[int (floor i)]\r\n\r\n(**\r\n## Input and output helpers \r\n\r\n### Keyboard input\r\nThe `Keyboard` module records the keys that are currently pressed in a set and\r\nregisters `window` event handlers using the DOM interoperability layer.\r\n*)\r\n\r\nmodule Keyboard =\r\n  /// Set of currently pressed keys\r\n  let mutable keysPressed = Set.empty\r\n  /// Update the keys as requested\r\n  let reset () = keysPressed <- Set.empty\r\n  let isPressed keyCode = Set.contains keyCode keysPressed\r\n  /// Triggered when key is pressed/released\r\n  let update (e : KeyboardEvent, pressed) =\r\n    let keyCode = int e.keyCode\r\n    let op =  if pressed then Set.add else Set.remove\r\n    keysPressed <- op keyCode keysPressed\r\n    null\r\n  /// Register DOM event handlers\r\n  let init () =\r\n    window.addEventListener_keydown(fun e -> update(e, true))\r\n    window.addEventListener_keyup(fun e -> update(e, false))\r\n\r\n(**\r\n### Choosing Pacman image\r\n\r\nThe `Pacman` module is a helper that exposes the `imageAt` function. The function\r\nreturns the pacman image for the specified X and Y location, taking into account the\r\ndirection in which Pacman is going. It keeps a mutable state with current step of Pacman's\r\nmouth.\r\n*)\r\n\r\nmodule Pacman =\r\n  // Load the different Pacman images \r\n  let private pu1, pu2 = createImage pu1, createImage pu2\r\n  let private pd1, pd2 = createImage pd1, createImage pd2\r\n  let private pl1, pl2 = createImage pl1, createImage pl2\r\n  let private pr1, pr2 = createImage pr1, createImage pr2\r\n  \r\n  // Represent Pacman's mouth state\r\n  let private lastp = ref pr1\r\n\r\n  // Return imge for the given X, Y and V\r\n  let imageAt(x,y,v) =\r\n    let p1, p2 =\r\n      match !v with\r\n      | -1,  0 -> pl1, pl2\r\n      |  1,  0 -> pr1, pr2\r\n      |  0, -1 -> pu1, pu2\r\n      |  0,  1 -> pd1, pd2\r\n      |  _,  _ -> !lastp, !lastp\r\n    let x' = int (floor(float (!x/6)))\r\n    let y' = int (floor(float (!y/6)))\r\n    let p = if (x' + y') % 2 = 0 then p1 else p2\r\n    lastp := p\r\n    p\r\n(**\r\n### Sounds and dots\r\n\r\nWe need two more helpers - the `sound` function plays an audio file. This uses JavaScript native\r\n`Audio` object, which we access via the `Emit` attribute. The other helper is `countDots` which\r\ncounts dots in the maze:\r\n*)\r\n/// Uses Fable's Emit to call JavaScript directly\r\n[<Emit(\"(new Audio($0)).play();\")>]\r\nlet sound(file:string) : unit = failwith \"never\"\r\n\r\n/// Count number of dots in the maze\r\nlet countDots () =\r\n  maze |> Array.sumBy (fun line ->\r\n    line.ToCharArray()\r\n    |> Array.sumBy (function '.' -> 1 | 'o' -> 1 | _ -> 0))\r\n\r\n(**\r\n## The game play function\r\n\r\nMost of the Pacman game logic is wrapped in the top-level `playLevel` function. This takes two functions - that are called\r\nwhen the game completes - and then it iniializes the world state and runs in a loop until the end of the game.\r\nThe following outlines the structure of the function:\r\n\r\n    let playLevel (onLevelCompleted, onGameOver) =\r\n      // (Create canvas, background and ghosts)\r\n      // (Define the Pacman state)\r\n      // (Move ghosts and Pacman)\r\n      // (Detect pills and collisiions)\r\n      // (Rendering everything in the game)\r\n      let rec update () =\r\n        logic ()\r\n        render ()\r\n        if !dotsLeft = 0 then onLevelCompleted()\r\n        elif !energy <= 0 then onGameOver()\r\n        else window.setTimeout(update, 1000. / 60.) |> ignore\r\n\r\n      update()\r\n\r\nAfter defining all the helpers, the `update` function runs in a loop (via a timer) until there are no dots\r\nleft or until the Pacman is out of energy and then it calls one of the continuations.\r\n\r\nIn the following 5 sections, we'll look at the 5 blocks of code that define the body of the function.\r\n*)\r\n(*** hide ***)\r\nlet playLevel (onLevelCompleted, onGameOver) =\r\n(**\r\n### Create canvas, background and ghosts\r\nIn the first part, the function finds the `<canvas>` element, paints it with black background and\r\ncreates other graphical elements - namely the game background, ghosts and eyes:\r\n*)\r\n  // Fill the canvas element\r\n  let canvas = document.getElementsByTagName_canvas().[0.]\r\n  canvas.width <- 256.\r\n  canvas.height <- 256.\r\n  let context = canvas.getContext_2d()\r\n  context.fillStyle <- U3.Case1 \"rgb(0,0,0)\"\r\n  context.fillRect (0., 0. , 256., 256.);\r\n  let bonusImages =\r\n    [| createImage _200; createImage _400;\r\n       createImage _800; createImage _1600 |]\r\n  \r\n  // Load images for rendering\r\n  let background = createBackground()\r\n  let ghosts = createGhosts(context)\r\n  let blue,eyed = createImage blue, createImage eyed\r\n(**\r\n### Define the Pacman state\r\nNext, we define the game state. Pacman game uses mutable state, so the following uses\r\nF# reference cells; `ref 0` creates a mutable cell containing 0. Later, we will access\r\nthe value by writing `!score` and mutate it by writing `score := !score + 1`.\r\n\r\n*)\r\n  let pills = maze |> Array.map (fun line ->\r\n    line.ToCharArray() |> Array.map (fun c -> c))\r\n  let dotsLeft = ref (countDots())\r\n  let score = ref 0\r\n  let bonus = ref 0\r\n  let bonuses = ref []\r\n  let energy = ref 128\r\n  let flashCountdown = ref 0\r\n  let powerCountdown = ref 0\r\n  let x, y = ref (16 * 8 - 7), ref (23 * 8 - 3)\r\n  let v = ref (0,0)\r\n(**\r\n### Move ghosts and Pacman\r\nAt each step of the game, we need to update the positions of ghosts and the Pacman. This is handled\r\nin `moveGhosts` and `movePacman`:\r\n*)\r\n  let moveGhosts () =\r\n    ghosts |> Array.iter (fun ghost ->\r\n      ghost.Move(chooseDirection ghost) )\r\n\r\n  let movePacman () =\r\n    // In which directions should pacman go?\r\n    let inputs =\r\n       [| if Keyboard.isPressed 81 (*q*) then\r\n            yield canGoUp (!x,!y), (0,-1)\r\n          if Keyboard.isPressed 65 (*a*) then\r\n            yield canGoDown (!x,!y), (0,1)\r\n          if Keyboard.isPressed 90 (*z*) then\r\n            yield canGoLeft (!x,!y), (-1,0)\r\n          if Keyboard.isPressed 88 (*x*) then\r\n            yield canGoRight (!x,!y), (1,0) |]\r\n    // Can we continue in the same direction?\r\n    let canGoForward =\r\n      match !v with\r\n      | 0,-1 -> canGoUp(!x,!y)\r\n      | 0,1  -> canGoDown(!x,!y)\r\n      | -1,0 -> canGoLeft(!x,!y)\r\n      | 1, 0 -> canGoRight(!x,!y)\r\n      | _ -> false\r\n    // What new directions can we take?\r\n    let availableDirections =\r\n      inputs\r\n      |> Array.filter fst\r\n      |> Array.map snd\r\n      |> Array.sortBy (fun v' -> v' = !v)\r\n    if availableDirections.Length > 0 then\r\n      // Choose the first one, prefers no change\r\n      v := availableDirections.[0]\r\n    elif inputs.Length = 0 || not canGoForward then\r\n      // There are no options - stop\r\n      v := 0,0\r\n\r\n    // Update X and Y accordingly\r\n    let x',y' = wrap (!x,!y) !v\r\n    x := x'\r\n    y := y'\r\n(**\r\n### Detect pills and collisiions\r\nThe most sophisticated part of the game logic is checking for various events. The following things can happen:\r\n\r\n - Pacman eats a small or a large pill - in which case, we play a sound and (optionally) switch to the power mode\r\n - Pacman clashes with a ghost - in which case it either loses energy, or eats the ghost when in power mode\r\n\r\nThe logic is captured by `eatPill`, `touchingGhosts` and `collisionDetection` functions:\r\n*)\r\n  // Check if Pacman eats a pill at current cell\r\n  let eatPills () =\r\n    let tx = int (floor(float ((!x+6)/8)))\r\n    let ty = int (floor(float ((!y+6)/8)))\r\n    let c = pills.[ty].[tx]\r\n    if c = '.' then\r\n      // Eating a small pill increments the score\r\n      pills.[ty].[tx] <- ' '\r\n      clearCell background (tx,ty)\r\n      score := !score + 10\r\n      decr dotsLeft\r\n      sound(\"./fx/Dot5.wav\")\r\n    if c = 'o' then\r\n      // Eating a large pill turns on the power mode\r\n      pills.[ty].[tx] <- ' '\r\n      clearCell background (tx,ty)\r\n      bonus := 0\r\n      score := !score + 50\r\n      powerCountdown := 250\r\n      decr dotsLeft\r\n      sound(\"./fx/Powerup.wav\")\r\n\r\n  /// Are there any ghosts that collide with Pacman?\r\n  let touchingGhosts () =\r\n    let px, py = !x, !y\r\n    ghosts |> Array.filter (fun ghost ->\r\n      let x,y = ghost.X, ghost.Y\r\n      ((px >= x && px < x + 13) ||\r\n       (x < px + 13 && x >= px)) &&\r\n      ((py >= y && py < y + 13) ||\r\n       (y < py + 13 && y >= py)) )\r\n(** \r\nThe `collisionDetection` function implements the right response to collision with a ghost:\r\n*)\r\n  /// Handle collision detections between Pacman and ghosts\r\n  let collisionDetection () =\r\n    let touched = touchingGhosts ()\r\n    if touched.Length > 0 then\r\n      if !powerCountdown > 0 then\r\n        // Pacman is eating ghosts!\r\n        touched |> Array.iter (fun ghost ->\r\n          if not ghost.IsReturning then\r\n            sound \"./fx/EatGhost.wav\"\r\n            ghost.IsReturning <- true\r\n            let added = int (2. ** (float !bonus))\r\n            score := !score + added * 200\r\n            let image = bonusImages.[!bonus]\r\n            bonuses := (100, (image, ghost.X, ghost.Y)) :: !bonuses\r\n            bonus :=  min 3 (!bonus + 1) )\r\n      else\r\n        // Pacman loses energy when hitting ghosts\r\n        decr energy\r\n        if !flashCountdown = 0 then sound \"./fx/Hurt.wav\"\r\n        flashCountdown := 30\r\n    if !flashCountdown > 0 then decr flashCountdown\r\n\r\n  /// Updates bonus points \r\n  let updateBonus () =\r\n    let removals,remainders =\r\n      !bonuses\r\n      |> List.map (fun (count,x) -> count-1,x)\r\n      |> List.partition (fst >> (=) 0)\r\n    bonuses := remainders\r\n\r\n(**\r\nThe logic is called from the following single `logic` function that includes all the checks:\r\n*)\r\n  let logic () =\r\n    moveGhosts()\r\n    movePacman()\r\n    eatPills ()\r\n    if !powerCountdown > 0 then decr powerCountdown\r\n    collisionDetection()\r\n    updateBonus ()\r\n(**\r\n### Rendering everything in the game\r\n\r\nWhen rendering everything in the game, we first draw the background and then we render\r\nindividual components. Those include the score, remaining energy, pacman, ghosts and bonuses.\r\nEach of those is handled by a single nested function that are put together in `render`.\r\nWe start with Pacman and remaining energy:\r\n*)\r\n  let renderPacman () =\r\n    let p = Pacman.imageAt(x,y,v)\r\n    if (!flashCountdown >>> 1) % 2 = 0\r\n    then context.drawImage(U3.Case1 p, float !x, float !y)\r\n\r\n  let renderEnergy () =\r\n    context.fillStyle <- U3.Case1 \"yellow\"\r\n    context.fillRect(120., 250., float !energy, 2.)\r\n(**\r\nThe next three functions render ghosts, current score and bonuses:\r\n*)\r\n  let renderGhosts () =\r\n    ghosts |> Array.iter (fun ghost ->\r\n      let image =\r\n        if ghost.IsReturning then eyed\r\n        else\r\n          if !powerCountdown = 0 then ghost.Image\r\n          elif !powerCountdown > 100 ||\r\n                ((!powerCountdown >>> 3) % 2) <> 0 then blue\r\n          else ghost.Image\r\n      context.drawImage(U3.Case1 image, float ghost.X, float ghost.Y) )\r\n\r\n  let renderScore () =\r\n    context.fillStyle <- U3.Case1 \"white\"\r\n    context.font <- \"bold 8px\";\r\n    context.fillText(\"Score \" + (!score).ToString(), 0., 255.)\r\n\r\n  let renderBonus () =\r\n    !bonuses |> List.iter (fun (_,(image,x,y)) ->\r\n      context.drawImage(U3.Case1 image, float x, float y))\r\n(** \r\nFinally, the `render` function puts everything together - note that this needs\r\nto be done in the right order so that we do not accidentally draw dots over a Pacman!\r\n*)\r\n  let render () =\r\n    context.drawImage(U3.Case2 background, 0., 0.)\r\n    renderScore ()\r\n    renderEnergy ()\r\n    renderPacman()\r\n    renderGhosts ()\r\n    renderBonus ()\r\n(*** hdie ***)\r\n  let rec update () =\r\n    logic ()\r\n    render ()\r\n    if !dotsLeft = 0 then onLevelCompleted()\r\n    elif !energy <= 0 then onGameOver()\r\n    else window.setTimeout(update, 1000. / 60.) |> ignore\r\n\r\n  update()\r\n\r\n(**\r\n## Game entry point\r\n\r\nNow we have everything we need to start the game, so the last step is to define the\r\n`levelCompleted` and `gameOver` functions (that are called when the game ends), render\r\nthe starting state of the game (with \"CLICK TO START\" text) and start the game!\r\n*)\r\nlet rec game () =\r\n  // Initialize keyboard and canvas\r\n  Keyboard.reset()\r\n  let canvas = document.getElementsByTagName_canvas().[0.]\r\n  let context = canvas.getContext_2d()\r\n\r\n  // A helper function to draw text\r\n  let drawText(text,x,y) =\r\n    context.fillStyle <- U3.Case1 \"white\"\r\n    context.font <- \"bold 8px\";\r\n    context.fillText(text, x, y)\r\n  \r\n  // Called when level is completed\r\n  let levelCompleted () =\r\n    drawText(\"COMPLETED\",96.,96.)\r\n    window.setTimeout((fun () -> game()),5000.) |> ignore\r\n  // Called when the game ends\r\n  let gameOver () =\r\n    drawText(\"GAME OVER\",96.,96.)\r\n    window.setTimeout((fun () -> game()),5000.) |> ignore\r\n\r\n  // Start a new game after click!\r\n  let start () =\r\n    let background = createBackground()\r\n    context.drawImage(U3.Case2 background, 0., 0.)\r\n    context.fillStyle <- U3.Case1 \"white\"\r\n    context.font <- \"bold 8px\";\r\n    drawText(\"CLICK TO START\", 88., 96.)\r\n    canvas.onclick <- (fun e ->\r\n      canvas.onclick <- null\r\n      playLevel (levelCompleted, gameOver)\r\n      box true )\r\n\r\n  // Resize canvas and get ready for a game\r\n  let canvas = document.getElementsByTagName_canvas().[0.]\r\n  canvas.width <- 256.\r\n  canvas.height <- 256.\r\n  start()\r\n\r\n// At the beginnin, initialize keyboard & start the first game.\r\nKeyboard.init ()\r\ngame ()\r\n"]}